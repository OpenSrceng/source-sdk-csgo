#! /usr/bin/env python

from waflib import TaskGen

class File:
	def __init__(self, name, fnFilter = None):
		self.name = name
		self.fnFilter = fnFilter
	def is_enabled(self, ctx):
		if self.fnFilter:
			return self.fnFilter(ctx)
		return True

def options(opt):
	# stub
	return

def configure(conf):
	conf.define('TIER0_DLL_EXPORT', 1)
	conf.define('CROSS_PLATFORM_VERSION', 1)
	conf.define_cond('THREAD_MUTEX_TRACING_ENABLED', conf.env.DEST_OS == 'win32')

def build(bld):
	sources = [
		File(['../unitlib/unitlib.cpp']),
		File(['assert_dialog.cpp']),
		File(['assert_dialog.rc'], lambda x: x.env.DEST_OS == 'win32'),
		File(['commandline.cpp']),
		File(['cpu.cpp']),
		File(['cpumonitoring.cpp']),
		File(['cputopology.cpp']),
		File(['cpu_posix.cpp'], lambda x: x.env.DEST_OS != 'win32'),
		File(['dbg.cpp']),
		File(['etwprof.cpp'], lambda x: x.env.DEST_OS == 'win32'),
		File(['fasttimer.cpp']),
		File(['logging.cpp']),
		File(['mem.cpp']),
		File(['mem_helpers.cpp']),
		File(['memdbg.cpp']),
		File(['memprocessheap.cpp'], lambda x: x.env.DEST_OS == 'win32'),
		File(['memvirt.cpp']),
		File(['memstd.cpp']),
		File(['memvalidate.cpp']),
		File(['dynfunction.cpp']),
		File(['minidump.cpp']),
		File(['tier0_strtools.cpp']),
		File(['miniprofiler.cpp']),
		File(['perfstats.cpp']),
		File(['platform.cpp'], lambda x: x.env.DEST_OS == 'win32'),
		File(['platform_posix.cpp'], lambda x: x.env.DEST_OS != 'win32'),
		File(['platform_independent.cpp']),
		File(['platwindow.cpp']),
		File(['pme.cpp'], lambda x: x.env.DEST_OS == 'win32'),
		File(['pme_posix.cpp'], lambda x: x.env.DEST_OS != 'win32'),
		File(['PMELib.cpp'], lambda x: x.env.DEST_OS == 'win32'),
		File(['progressbar.cpp']),
		File(['security.cpp']),
		File(['stackstats.cpp']),
		File(['stacktools.cpp']),
		File(['systeminformation.cpp']),
		File(['threadtools.cpp']),
		File(['tslist.cpp']),
		File(['vatoms.cpp']),
		File(['vprof.cpp']),
		File(['vtuneinterface.cpp']),
		File(['win32consoleio.cpp']),
		File(['dlmalloc/malloc.cpp'], lambda x: x.env.DEST_OS == 'win32')
	]

	includes = [
		'.',
		'../public',
		'../public/tier0',
		'../public/tier1',
		'../thirdparty/SDL2'
	]

	libs = []

	sources_platform = []
	for i in sources:
		if not i.is_enabled(bld):
			continue
		sources_platform += i.name

	bld.shlib(
		target   = 'tier0',
		features = 'c cxx',
		source   = sources_platform,
		includes = includes,
		use      = libs,
		idx      = 0,
		install_path = bld.env.LIBDIR,
		subsystem = bld.env.MSVC_SUBSYSTEM
	)
